# Product Requirements Document (PRD) - v1.3

## Adaptive Automated Trading Strategy Discovery System

### Introduction

The Adaptive Automated Trading Strategy Discovery System is a Python-based solution designed to autonomously discover, evaluate, and evolve **short-term trading strategies** (defined as strategies with typical holding periods ranging from intraday up to several weeks) specifically tailored for NSE equity stocks. Leveraging genetic algorithms (GA), heuristic analysis, and robust backtesting, the system iteratively refines strategies, minimizing manual intervention and maximizing interpretability. This MVP provides retail traders and analysts with a transparent, automated, and adaptive tool to systematically identify potentially profitable trading strategies without manual rule-writing, focusing initially on local Windows execution.

## Goals and Objectives

### Project Objectives

-   Automate discovery and evolution of potentially profitable short-term trading strategies for NSE equities.
-   Provide clear, interpretable strategies evolving based on historical performance and heuristic feedback.
-   Enable analysts to easily review and validate strategy evolution through concise, human-readable reports.
-   Ensure strategies demonstrate robustness, generalizability, and incorporate checks against overfitting to historical data.

### Measurable Outcomes

-   Reduction in manual effort required for strategy discovery and refinement.
-   Improvement in strategy performance metrics (net profit, Sharpe ratio, win rate, max drawdown) compared to defined baseline strategies.
-   Increased analyst confidence in automated strategy evolution through clear reporting and transparency.

### Success Criteria

-   System autonomously generates and evolves strategies outperforming pre-defined simple baseline strategies (e.g., Buy-and-Hold on NIFTY 50 index, Simple Moving Average Crossover like 50-day vs 200-day on representative stocks) based on backtester output metrics.
-   Analysts clearly understand strategy logic (rules, parameters), performance, evolution rationale (heuristic tags applied, major changes), and robustness from generated reports.
-   Strategies demonstrate robustness when tested across different historical periods and market conditions (e.g., high vs. low volatility periods, trending vs. range-bound periods) during backtesting, including passing validation across multiple segments within a defined test window (e.g., 1 year).
-   MVP Validation: Success will be validated by comparing the key performance metrics (Net Profit, Sharpe Ratio, Win Rate, Max Drawdown) generated by the system's evolved strategies against the defined baseline strategies using the Strategy Backtester output. Robustness will be assessed by running backtests across different, pre-defined historical periods and stock selections, including out-of-sample data segments and checking for performance degradation over time.

### Key Performance Indicators (KPIs)

| KPI    | Description    |
| :---- | :---- |
| Net Profit Improvement   | Strategies outperform baseline net profit    |
| Sharpe Ratio Improvement | Higher risk-adjusted return (Sharpe ratio) compared to baseline    |
| Strategy Robustness    | Consistent performance across diverse, pre-defined market regimes/periods |
| Analyst Satisfaction    | High ease-of-use and interpretability ratings based on report clarity    |
| Overfitting Metric    | Acceptable divergence between in-sample and out-of-sample performance    |
| Validation Pass Rate | Percentage of top strategies passing pre-defined robustness/validation criteria |

---

## MVP Scope and Requirements

### Functional Requirements

#### Capability 1: Automated Feature Generation (`FeatureFactory`)

-   Fetch historical NSE equity data (OHLCV) via `yfinance`.
-   Implement local caching for fetched data to minimize redundant API calls and handle potential rate limits.
-   Generate a configurable set of **strategy ingredients (features)** derived purely from chart data. The system should be capable of generating features including, but not limited to:
    *   **Price-based:** OHLC percentage changes (e.g., 1, 2, 3, 5, 10-day lags), relative position within recent highs/lows, breakout signals, gap detection.
    *   **Technical Indicators:** Standard indicators like SMA, EMA, MACD, RSI, Stochastics, Bollinger Bands, ADX, etc., with configurable parameters.
    *   **Volume Analysis:** Volume spikes relative to average, VWAP deviations, volume/price divergence patterns.
    *   **Volatility Measures:** Rolling standard deviation, Average True Range (ATR), price range ratios.
    *   **Statistical Patterns:** Z-scores of price/indicators relative to rolling means, position within Bollinger Bands.
    *   **Correlations:** Rolling correlations with relevant benchmarks (e.g., Sector ETF/Index, NIFTY/SENSEX) and potentially closely related stocks (peer group).
    *   **Candlestick Patterns:** Recognition of common patterns (e.g., Pin bar, Engulfing, Hammer, Doji).
    *   **Relative Performance:** Percentage move relative to NIFTY, SENSEX, or defined industry peers.
    *   **Time-based Patterns:** Features representing day-of-week or day-of-month.
-   Output feature data primarily as Pandas DataFrames, forming a rich, structured feature set programmatically.

#### Capability 2: Strategy Backtesting (`StrategyBacktester`)

-   Evaluate trading strategies defined by a **standardized rule format** (see Technical Constraints) against historical feature/price data (input as Pandas DataFrames).
-   Calculate key performance metrics (Net Profit, Sharpe Ratio, Win Rate, Max Drawdown, Sortino Ratio, Calmar Ratio, Trade Statistics including signal frequency).
-   Generate basic visualizations (e.g., equity curves, trade entry/exit points on price charts) - potentially using libraries like Matplotlib/Seaborn, saved as image files or displayed directly if run interactively.
-   Output metrics and trade logs in a structured format (e.g., dictionary, JSON, or simple text report).
-   Incorporate basic checks for potential overfitting (e.g., comparing performance on different data segments).
-   Support for Adversarial Simulation: The backtester must be capable of running evaluations on specific slices of historical data representing different market characteristics (e.g., high/low volatility, bull/bear markets, low liquidity days) as defined in the Testing Requirements.

#### Capability 3: Genetic Algorithm-Based Strategy Optimization (`StrategyOptimizer`)

-   Define and manage the structure for representing trading strategies (rules, parameters) internally, aligning with the standardized rule format.
-   Automatically generate an initial population of simple trading strategies.
-   Evolve strategies using genetic operations based on fitness derived from `StrategyBacktester` results. Fitness function to be configurable. Key evolutionary mechanisms include:
    *   **Genetic-style Evolution:** Employ techniques like crossover (combining rules/parameters from successful parent strategies) and selection (promoting top performers to the next generation).
    *   **Rule Mutation:** Introduce variations by tweaking rule thresholds, switching indicators within rules, adding/removing filters, or modifying logic operators.
-   Implement heuristic mechanisms focused on learning from failure and improving robustness:
    *   **Heuristic Tagging (Root Cause Analysis):** Automatically tag poor-performing or discarded strategies to understand reasons for failure by examining specific patterns. Tags should include, but are not limited to:
        *   `Whipsaw`: Signals generated in choppy, range-bound markets leading to losses. (Analysis: Track volatility/ADX at signal time vs. trade outcome).
        *   `Late Entry`: Signal fires after a significant portion of the price move has already occurred. (Analysis: Compare entry time vs. start of the identified price swing).
        *   `Bad Exit`: Profitable trades reverse significantly before exit, giving back gains. (Analysis: Track peak profit vs. exit profit).
        *   `Noisy Indicator`: Specific indicator(s) generate excessive false signals. (Analysis: Track success rate of signals generated by specific indicators, potentially requiring volume/volatility confirmation).
        *   `Overfitting`: Strategy performs well in-sample but poorly on specific out-of-sample segments or different market regimes. (Analysis: Compare performance metrics across different data slices).
        *   `Low Generality`: Strategy works only on a very specific stock or during a narrow market phase. (Analysis: Track performance consistency across different instruments/time periods).
        *   `Trade Frequency Issue`: Too many or too few trades generated.
    *   **Feedback-Driven Rule Modification:** Implement a mechanism where identified failure tags influence subsequent genetic operations or rule adjustments. For example:
        *   `Whipsaw` tag → Prioritize adding trend-confirming filters (e.g., ADX > threshold, MA slope) during mutation/crossover.
        *   `Late Entry` tag → Favor mutations towards indicators known for earlier signals (e.g., shorter MA periods, faster oscillators).
        *   `Bad Exit` tag → Encourage exploration of dynamic exit conditions (e.g., trailing stops based on ATR, reversal signals like RSI crossing back).
        *   `Noisy Indicator` tag → Increase probability of adding volume or volatility filters (e.g., volume > avg volume, ATR > threshold) to rules using that indicator.
        *   `Trade Frequency Issue` (too high) → Favor widening indicator thresholds or adding cool-down periods after trades.
    *   **Evolutionary Fitness Shaping:** Adjust fitness scores based not just on raw profit, but also incorporating heuristic tags and robustness metrics. Specifically:
        *   Penalize strategies tagged with failure modes (e.g., `Whipsaw`, `Overfitting`).
        *   Reward robustness (e.g., low variance of returns, low maximum drawdown, consistent performance across regimes).
        *   Penalize strategies that achieve high returns rarely but with high variance (jackpot strategies).
        *   Encourage diversity by potentially scoring the uniqueness of a strategy's logic compared to the rest of the population (e.g., using different combinations of indicators/parameters).
    *   **Strategy Archetype Clustering (Potential Future Enhancement / Advanced Heuristic):** Implement clustering (e.g., K-Means, DBSCAN) on failed or successful strategies based on their structural representation (e.g., vector of indicator types, parameter ranges, rule complexity). If a specific cluster (e.g., "simple breakout strategies") consistently underperforms over generations, the system could deprioritize generating similar strategies.
    *   **Bayesian Strategy Update (Potential Future Enhancement / Advanced Heuristic):** Maintain a probabilistic belief (e.g., using `scipy.stats`) about the effectiveness of certain rule structures or indicator combinations. Update this belief based on observed performance (prior belief + observed data → posterior belief). Lower posterior confidence could reduce the likelihood of selecting or generating similar patterns in future generations.
    *   **Meta-Strategy Critic (Optional ML - Potential Future Enhancement):** Train a lightweight ML model (e.g., Decision Tree, Logistic Regression) using historical trade outcomes (success/failure) as labels and features derived from market state and indicator values at the time of the signal. This model could act as an additional filter or guide during strategy generation or selection, predicting the likelihood of success for a candidate trade/strategy.

#### Capability 4: Analyst Reporting and Heuristic Analysis (`StrategyAnalyzer`)

-   Consume outputs from the `StrategyBacktester` and `StrategyOptimizer`.
-   Perform heuristic analysis based on tags applied during optimization and backtest results.
-   Generate concise, human-readable analyst reports summarizing strategy performance, evolution, and robustness.
-   **Output Requirements:** The system must generate:
    1.  **Top Strategies Report:** For each stock or analysis run, list the top-performing strategies including:
    *   Strategy Logic: Clear, readable representation of the rules and parameters.
    *   Backtest Performance: Key metrics (Net Profit, Max Drawdown, Sharpe Ratio, etc.).
    *   Signal Frequency: Average number of trades per period.
    *   Validation Status: Indication of whether the strategy passed robustness/validation checks (e.g., performance across multiple segments, degradation check).
    *   **Heuristic Tags:** List any relevant tags applied during analysis (e.g., `Robust`, `Low Drawdown`, or potential failure tags if still present).
    2.  **Failures Report:** A summary report identifying:
    *   Common reasons for poor strategy performance based on Failure Tags (e.g., "Whipsaw was common in 35% of discarded strategies").
    *   Specific patterns, indicators, or **strategy archetypes (if clustering implemented)** that consistently underperformed during the optimization process.
-   **Standard Report Structure:** The main analyst report (e.g., Markdown or PDF) should integrate information from the above outputs and include sections for: Strategy Definition, Overall Performance Metrics, In-Sample vs. Out-of-Sample Performance, Equity Curve Visualization, Trade Log Summary, Heuristic/Failure Tags Applied, Evolution Path Summary (high-level), and Robustness/Validation Test Results (including performance across different regimes/adversarial simulations).
-   **Interpretability Depth:** Reports should allow an analyst with trading knowledge but minimal GA expertise to understand *what* the strategy does, *how well* it performed, *why* some strategies failed, *what characteristics* (heuristics) it exhibits, and *how robust* it appears based on the defined tests.

---

### Non-Functional Requirements (NFRs)


| Category    | Requirement    |
| :---- | :---- |
| Performance    | Efficient backtesting and optimization suitable for typical multi-core local Windows PC execution. Implement performance profiling. **Utilize `multiprocessing` where feasible** (e.g., parallelizing backtests within GA generations) to improve throughput. |
| Scalability    | Modular design using distinct Python packages (`FeatureFactory`, `StrategyBacktester`, `StrategyOptimizer`, `StrategyAnalyzer`) with clear interfaces to facilitate future enhancements. Avoid tight coupling to local resources. |
| Reliability    | Robust error handling. Structured logging (e.g., using Python's `logging` module) for debugging and tracing. Log key GA evolution metrics and run configurations. |
| Security    | Local execution minimizes external threats for MVP.    |
| Maintainability | Clear, modular, well-documented Python code (PEP 8, linters, type hinting). Comprehensive docstrings and READMEs. Adhere to KISS principle.    |
| Usability    | Clear, intuitive analyst reports (prototype early). Well-documented command-line/script interface with clear parameters, validation, and user feedback.    |
| Data Handling   | Implement local caching for `yfinance` data. Define strategy for managing datasets (stock lists, date ranges) via configuration files.    |
| Configuration   | Utilize external configuration files (e.g., YAML or JSON) for managing parameters. Log the configuration used for each run.    |
| Constraints    | Python-only implementation (MVP). Exclusive use of `yfinance` (MVP). Local Windows execution target (MVP).    |

---

### User Experience (UX) Requirements
-   **Analyst Report Clarity:** The primary UX. Reports must be structured logically, prioritizing key information. Prototype report formats early and iterate based on target user feedback.
-   **Ease of Use:** Minimal setup friction via clear documentation and potentially a simple setup script. Intuitive command-line arguments or script parameters with helpful messages and validation.
-   **Transparency:** Users should understand the system's status during runs via clear console logging. Final reports must clearly explain the strategy and its evaluation.

---

### Integration Requirements
-   **Data Source:** Integration with `yfinance` API for historical NSE equity data retrieval.
-   **Internal:** Define and maintain clear APIs and data contracts between the internal Python packages.

---

### Testing Requirements
-   **Unit Tests:** Comprehensive unit tests (`pytest` preferred) for functions and classes within each package.
-   **Integration Tests:** Tests validating the interactions and data handoffs between packages.
-   **Robustness & Validation Testing Methodology:** Define and implement specific tests for strategy robustness. This must include:
    *   Testing on explicitly defined out-of-sample data segments.
    *   **Adversarial Simulation:** Testing across different, pre-defined market regimes/historical periods by running backtests on specific data slices representing characteristics like:
        *   High vs. Low volatility periods (e.g., using rolling ATR or std dev thresholds).
        *   Strong Bullish / Bearish market phases (e.g., based on index performance like NIFTY 50).
        *   Identified periods of low liquidity (if data allows).
        *   Specific historical stress events (e.g., Feb-Mar 2020, June 2022).
    *   **Validation Window:** Validation should occur across multiple segments within a defined test window (e.g., 1 year).
    *   **Performance Degradation Checks:** Flag strategies where performance significantly degrades over time or between different test segments/regimes. Tag strategies that only work in one regime as `Non-Robust` or `Regime Specific`.
    *   Potentially testing sensitivity to small parameter variations (if feasible in MVP).
-   **Overfitting Checks:** Implement specific checks within the `StrategyAnalyzer` or `StrategyBacktester` to compare in-sample vs. out-of-sample performance metrics.
-   **Reporting Tests:** Tests to verify the correct generation, structure, and content of the analyst reports, including the Top Strategies and Failures reports, and the correct reporting of heuristic tags and validation results.
-   **Test Data:** Define and use standardized datasets for consistent testing, including datasets representing different market regimes for adversarial simulation.

---

## Epic Overview (MVP)

| Epic    | Goal    | Key Packages Involved |
| :---- | :---- | :---- |
| Epic 1: Core Framework & Data Handling | Setup project, fetch/cache data, generate basic features.    | `FeatureFactory`    |
| Epic 2: Strategy Backtesting Engine    | Evaluate strategies based on defined rules, calculate metrics, generate basic plots.    | `StrategyBacktester`  |
| Epic 3: GA Strategy Optimizer    | Implement GA core loop, evolve strategies based on fitness, apply initial heuristics.    | `StrategyOptimizer`   |
| Epic 4: Analysis & Reporting    | Analyze backtest/optimization results, perform heuristic analysis, generate analyst reports. | `StrategyAnalyzer`    |

---

## Initial Architect Prompt (Guidance for Detailed Design)

### Technical Infrastructure

-   **Version Control:** Mandatory use of Git.
-   **Project Structure:** Modular Python packages (`pyproject.toml` preferred).
-   **Hosting:** Local Windows PC (MVP).
-   **Frontend:** N/A (CLI/Script-based).
-   **Backend:** Python packages (`FeatureFactory`, `StrategyBacktester`, `StrategyOptimizer`, `StrategyAnalyzer`).
-   **Database:** N/A (Local files - CSV, Parquet, JSON/YAML).
-   **Configuration:** External files (YAML/JSON).

### Technical Constraints & Interfaces

-   Python-only; `yfinance` only (MVP).
-   Optimize for local Windows execution (consider `multiprocessing`).
-   Modular design.
-   **Standardized Strategy Rule Format:** Define clear, serializable format (e.g., JSON schema) - **Priority Task**.
-   **Package Interfaces:** Define clear Python APIs and data contracts.
-   **Data Exchange:** Pandas DataFrames (consistent schemas).

### Deployment Considerations

-   Local deployment (MVP).
-   **Setup:** Clear documentation + setup script (`venv`, pinned dependencies).
-   **Dependency Management:** `pyproject.toml` or pinned `requirements.txt`.
-   **(Optional Consideration):** Evaluate Docker for local deployment consistency.

### Local Development & Testing Requirements

-   Virtual environments (`venv`).
-   Unit tests (`pytest`), Integration tests.
-   Utility scripts for execution/testing.
-   Code quality tools (linters, formatters), documentation standards.

### Other Technical Considerations

-   Minimal security concerns (local MVP).
-   Design for future scalability.
-   Structured logging, configuration logging, GA metric logging.
-   **Architectural Diagram:** Develop detailed diagram showing data flow and interactions.


## Post-MVP / Future Enhancements

*(Updated to reflect potential future status of advanced heuristics)*

-   Integration with broker APIs (e.g., Zerodha).
-   Incorporation of alternative data sources.
-   Cloud-based scalability.
-   More sophisticated heuristic analysis and evolution mechanisms:
    *   **Strategy Archetype Clustering:** Formal implementation and integration into fitness/selection.
    *   **Bayesian Strategy Updates:** Implementing probabilistic confidence tracking for rules/patterns.
    *   **Meta-Strategy Critic (ML):** Developing and integrating the predictive ML model.
    *   **Persistent Strategy Memory:** Storing and referencing past failed patterns across runs.
-   Web-based UI for configuration, monitoring, and report viewing.
-   Support for other asset classes (e.g., Futures & Options, Forex) or markets.
