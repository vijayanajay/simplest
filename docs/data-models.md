# Adaptive Automated Trading Strategy Discovery System Data Models

## 1. Overview

This document defines the core data structures, entities, and schemas used throughout the Adaptive Automated Trading Strategy Discovery System. These models ensure data consistency, facilitate validation, and provide clear contracts between different components of the system. Pydantic is the primary tool for defining and validating these models.

## 2. Core Application Entities / Domain Objects

These are the fundamental objects and concepts the application works with.

### StockDataPoint

-   **Description:** Represents a single point of market data (OHLCV) for a stock at a specific time, potentially augmented with technical indicators.
-   **Schema / Pydantic Model:**
    from datetime import datetime
from typing import Dict, Optional
from pydantic import BaseModel, Field

class StockDataPoint(BaseModel):
    timestamp: datetime = Field(..., description="Timestamp of the data point (e.g., end of day/bar)")
    symbol: str = Field(..., description="Stock ticker symbol")
    open: float = Field(..., description="Opening price")
    high: float = Field(..., description="Highest price")
    low: float = Field(..., description="Lowest price")
    close: float = Field(..., description="Closing price")
    volume: int = Field(..., description="Trading volume")
    indicators: Optional[Dict[str, float]] = Field(default_factory=dict, description="Calculated technical indicators (e.g., {'SMA_20': 150.5, 'RSI_14': 65.0})")
-   **Validation Rules:**
    *   `open`, `high`, `low`, `close`, `volume` must be non-negative.
    *   `high` must be >= `low`, `high` >= `open`, `high` >= `close`.
    *   `low` must be <= `open`, `low` <= `close`.

### TradingSignal

-   **Description:** Represents a trading signal generated by a strategy.
-   **Schema / Pydantic Model (Conceptual - often an Enum):**
    from enum import Enum

class SignalType(str, Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    NO_SIGNAL = "NO_SIGNAL" # Explicitly state no action

### Trade

-   **Description:** Represents an executed trade during a backtest.
-   **Schema / Pydantic Model:**
    from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

class Trade(BaseModel):
    trade_id: str = Field(..., description="Unique identifier for the trade")
    symbol: str = Field(..., description="Stock ticker symbol")
    entry_timestamp: datetime = Field(..., description="Timestamp of trade entry")
    entry_price: float = Field(..., description="Price at which the trade was entered")
    exit_timestamp: Optional[datetime] = Field(None, description="Timestamp of trade exit")
    exit_price: Optional[float] = Field(None, description="Price at which the trade was exited")
    shares: float = Field(..., description="Number of shares traded")
    direction: str = Field(..., description="Direction of the trade ('LONG' or 'SHORT')") # Could be an Enum
    profit_loss: Optional[float] = Field(None, description="Profit or loss from the trade")
    profit_loss_percent: Optional[float] = Field(None, description="Profit or loss percentage")
    holding_period_bars: Optional[int] = Field(None, description="Duration of the trade in bars/periods")

### StrategyRuleCondition

-   **Description:** Defines a single condition within a trading strategy rule, based on the JSON format described in PRD (Capability 2).
-   **Schema / Pydantic Model:**
    from typing import Union, List
from pydantic import BaseModel, Field

class StrategyRuleCondition(BaseModel):
    indicator: str = Field(..., description="Name of the technical indicator or price component (e.g., 'SMA_20', 'RSI_14', 'close')")
    operator: str = Field(..., description="Comparison operator (e.g., '>', '<', 'crosses_above', 'crosses_below', '==')")
    value_type: str = Field(..., description="Type of the value to compare against ('indicator' or 'literal')")
    value: Union[str, float, int] = Field(..., description="The indicator name (if value_type is 'indicator') or the literal value to compare against")
    # Optional: parameters for indicators if they are dynamically generated or compared
    # e.g., indicator_params: Optional[Dict[str, Union[int, float]]] = None
    # e.g., value_indicator_params: Optional[Dict[str, Union[int, float]]] = None

### StrategyRule

-   **Description:** A set of conditions that, when met, trigger a trading signal (BUY or SELL).
-   **Schema / Pydantic Model:**
    from typing import List
from pydantic import BaseModel, Field

class StrategyRule(BaseModel):
    signal: SignalType = Field(..., description="The signal to generate if conditions are met (BUY or SELL)")
    conditions: List[StrategyRuleCondition] = Field(..., description="List of conditions that must ALL be true for the rule to trigger (logical AND)")
    # Optional: rule_id: str for easier tracking

### TradingStrategy

-   **Description:** Represents a complete trading strategy, composed of multiple rules, metadata, and parameters. This is what the GA evolves.
-   **Schema / Pydantic Model:**
    from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field

class TradingStrategy(BaseModel):
    strategy_id: str = Field(..., description="Unique identifier for the strategy")
    name: Optional[str] = Field(None, description="Human-readable name for the strategy")
    description: Optional[str] = Field(None, description="Detailed description of the strategy logic")
    buy_rules: List[StrategyRule] = Field(..., description="List of rules that can trigger a BUY signal")
    sell_rules: List[StrategyRule] = Field(..., description="List of rules that can trigger a SELL signal")
    parameters: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Strategy-specific parameters (e.g., stop-loss percentage, take-profit target, position sizing)")
    # Metadata from GA evolution
    generation: Optional[int] = Field(None, description="GA generation number where this strategy was prominent")
    fitness_score: Optional[float] = Field(None, description="Fitness score achieved during GA evaluation")
    other_ga_metrics: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Other metrics recorded during GA")
-   **Validation Rules:**
    *   `strategy_id` must be unique.
    *   At least one buy rule or one sell rule must be present.

### BacktestMetrics

-   **Description:** A collection of performance metrics resulting from a backtest of a trading strategy. (Refer to PRD "Measurable Outcomes" and "KPIs").
-   **Schema / Pydantic Model:**
    from typing import List, Dict, Optional
from pydantic import BaseModel, Field

class BacktestMetrics(BaseModel):
    strategy_id: str = Field(..., description="Identifier of the strategy backtested")
    config_snapshot: Dict = Field(..., description="Snapshot of the configuration used for this backtest")
    total_net_profit: float = Field(..., description="Total net profit or loss")
    total_return_percent: float = Field(..., description="Total return percentage")
    sharpe_ratio: Optional[float] = Field(None, description="Sharpe Ratio")
    sortino_ratio: Optional[float] = Field(None, description="Sortino Ratio")
    max_drawdown_percent: float = Field(..., description="Maximum drawdown percentage")
    win_rate_percent: float = Field(..., description="Percentage of winning trades")
    loss_rate_percent: float = Field(..., description="Percentage of losing trades")
    average_win_profit_percent: Optional[float] = Field(None, description="Average profit percentage of winning trades")
    average_loss_percent: Optional[float] = Field(None, description="Average loss percentage of losing trades")
    profit_factor: Optional[float] = Field(None, description="Gross profit / Gross loss")
    total_trades: int = Field(..., description="Total number of trades executed")
    average_holding_period_bars: Optional[float] = Field(None, description="Average holding period in bars")
    trades: List[Trade] = Field(..., description="List of all trades executed")
    # Add other KPIs from PRD: e.g., Annualized Return, Volatility, Skewness, Kurtosis, Calmar Ratio
    # Add interpretability metrics if quantifiable

### GAIndividual

-   **Description:** Represents an individual (a candidate trading strategy) within the Genetic Algorithm's population.
-   **Schema / Pydantic Model (Conceptual - actual representation might be more complex or a direct `TradingStrategy` object):**
    from pydantic import BaseModel, Field

class GAIndividual(BaseModel):
    # The 'chromosome' could be a direct TradingStrategy object,
    # or a more abstract representation that decodes into a TradingStrategy.
    # For simplicity, let's assume it's a TradingStrategy.
    strategy: TradingStrategy = Field(..., description="The trading strategy represented by this individual")
    fitness: Optional[float] = Field(None, description="Fitness score of the individual")
    # Other GA-specific attributes like age, diversity metrics, etc.

### GAEvolutionLogEntry

-   **Description:** A record capturing key metrics for each generation of the GA, for logging and analysis.
-   **Schema / Pydantic Model (for JSON Lines output):**
    from typing import List, Dict, Any
from pydantic import BaseModel, Field

class GAEvolutionLogEntry(BaseModel):
    generation: int = Field(..., description="Generation number")
    timestamp: datetime = Field(..., description="Timestamp of generation completion")
    best_fitness: float = Field(..., description="Fitness of the best individual in this generation")
    average_fitness: float = Field(..., description="Average fitness of the population")
    population_size: int = Field(..., description="Number of individuals in the population")
    best_individual_id: str = Field(..., description="ID of the best strategy in this generation")
    # Optional: diversity_metric: float
    # Optional: other_summary_stats: Dict[str, Any]
-   **CSV Format Equivalent:**
    *   Columns: `generation`, `timestamp`, `best_fitness`, `average_fitness`, `population_size`, `best_individual_id`, ...

## 3. API Payload Schemas (If distinct)

### CLIConfiguration (config.yaml)

-   **Description:** Defines the structure of the main `config.yaml` file used to control the system's execution via the CLI. This is the primary "API" for user interaction.
-   **Schema / Pydantic Model (Illustrative - to be fully defined based on `prd.md` "Configuration File (`config.yaml`)"):**
    from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field, validator

class DataSourceConfig(BaseModel):
    provider: str = Field("yfinance", description="Data provider, e.g., 'yfinance', 'local_csv'")
    api_key_env_var: Optional[str] = Field(None, description="Environment variable name for API key if needed")
    symbols: List[str] = Field(..., description="List of stock ticker symbols")
    start_date: str = Field(..., description="Start date for historical data (YYYY-MM-DD)")
    end_date: str = Field(..., description="End date for historical data (YYYY-MM-DD)")
    interval: str = Field("1d", description="Data interval (e.g., '1d', '1h')")
    # For local_csv: path_template: str

class FeatureConfig(BaseModel):
    # Define parameters for feature generation, e.g., indicator periods
    # Example: sma_periods: List[int] = [10, 20, 50]
    # Example: rsi_periods: List[int] = [14]
    custom_feature_scripts: Optional[List[str]] = Field(default_factory=list, description="Paths to custom feature generation scripts")
    pass # ... more feature settings

class GAConfig(BaseModel):
    population_size: int = Field(100, ge=10)
    generations: int = Field(50, ge=1)
    mutation_rate: float = Field(0.1, ge=0.0, le=1.0)
    crossover_rate: float = Field(0.7, ge=0.0, le=1.0)
    # Define fitness function components and weights
    # Define genetic operators and their parameters
    # Define rule complexity limits
    checkpoint_interval: Optional[int] = Field(10, description="Save GA state every N generations")
    checkpoint_path_template: str = Field("./ga_checkpoints/gen_{generation}.pkl", description="Path template for GA checkpoints")
    evolution_log_path: str = Field("./ga_evolution_log.jsonl", description="Path for GA evolution log (JSON Lines or CSV)")
    pass # ... more GA settings

class BacktestConfig(BaseModel):
    initial_capital: float = Field(100000.0, gt=0)
    commission_percent: float = Field(0.001, ge=0.0) # 0.1%
    slippage_percent: float = Field(0.0005, ge=0.0) # 0.05%
    # Define backtesting period (can be different from data fetching period)
    # backtest_start_date: str
    # backtest_end_date: str
    pass # ... more backtesting settings

class ReportingConfig(BaseModel):
    output_directory: str = Field("./reports", description="Directory to save reports")
    report_formats: List[str] = Field(["html", "markdown", "csv"], description="Formats for the final report")
    top_n_strategies: int = Field(5, description="Number of top strategies to detail in the report")
    # plot_generation: bool = True

class CLIConfiguration(BaseModel):
    run_id: Optional[str] = Field(None, description="Optional unique ID for this run, auto-generated if None")
    data_source: DataSourceConfig
    feature_engineering: FeatureConfig
    genetic_algorithm: GAConfig
    backtesting: BacktestConfig
    reporting: ReportingConfig
    logging_level: str = Field("INFO", description="Logging level (DEBUG, INFO, WARNING, ERROR)")
    # Add other global settings from PRD config.yaml description

    @validator('run_id', pre=True, always=True)
    def set_run_id_if_none(cls, v):
        import uuid
        return v or str(uuid.uuid4())

    - **Provide clear initial setup instructions:** Add notes on automated validation and setup for environment variables and configuration files to ensure seamless integration during spike phases.

### ReportData

-   **Description:** Structure of the data object passed to the reporting engine to generate various output formats (HTML, Markdown, CSV).
-   **Schema / Pydantic Model (Conceptual):**
    from typing import List, Dict, Any
from pydantic import BaseModel, Field

class ReportStrategyDetail(BaseModel):
    strategy: TradingStrategy
    backtest_metrics: BacktestMetrics
    # Optional: plots_data: Dict[str, Any] (data for generating charts)

class ReportData(BaseModel):
    run_id: str
    run_timestamp: datetime
    config_used: CLIConfiguration # Snapshot of the config
    overall_summary: Dict[str, Any] # High-level summary of the GA run
    top_strategies_detailed: List[ReportStrategyDetail]
    ga_evolution_summary: Optional[List[GAEvolutionLogEntry]] = None # Or path to the log file
    # Other sections as needed for the report

## 4. Database Schemas (If applicable)

The system uses SQLite for local caching of market data and potentially technical indicators to speed up repeated runs and reduce API calls.

### CachedMarketData Table

-   **Purpose:** Stores downloaded OHLCV market data.
-   **SQLite Schema Definition:**
    ```sql
    CREATE TABLE IF NOT EXISTS cached_market_data (
        symbol TEXT NOT NULL,
        timestamp INTEGER NOT NULL, -- Unix timestamp (seconds) for easier indexing with datetime
        open REAL NOT NULL,
        high REAL NOT NULL,
        low REAL NOT NULL,
        close REAL NOT NULL,
        volume INTEGER NOT NULL,
        data_source TEXT NOT NULL, -- e.g., 'yfinance'
        fetch_datetime TEXT NOT NULL, -- ISO8601 timestamp of when data was fetched
        interval TEXT NOT NULL, -- e.g., '1d', '1h'
        version TEXT NOT NULL DEFAULT '1.0', -- Version of the data schema or processing
        checksum TEXT, -- Optional: MD5 or SHA256 hash of the data for integrity
        PRIMARY KEY (symbol, timestamp, interval, data_source)
    );

    CREATE INDEX IF NOT EXISTS idx_market_data_symbol_interval ON cached_market_data (symbol, interval);
    CREATE INDEX IF NOT EXISTS idx_market_data_timestamp ON cached_market_data (timestamp);
    ```

### CachedIndicatorData Table (Optional, if indicators are pre-calculated and cached)

-   **Purpose:** Stores pre-calculated technical indicator values.
-   **SQLite Schema Definition:**
    ```sql
    CREATE TABLE IF NOT EXISTS cached_indicator_data (
        symbol TEXT NOT NULL,
        timestamp INTEGER NOT NULL, -- Unix timestamp (seconds)
        interval TEXT NOT NULL, -- e.g., '1d', '1h'
        indicator_name TEXT NOT NULL, -- e.g., 'SMA', 'RSI'
        parameters_json TEXT NOT NULL, -- JSON string of indicator parameters, e.g., {"period": 20}
        value REAL NOT NULL,
        data_source TEXT NOT NULL, -- Source of the base OHLCV data
        calculation_datetime TEXT NOT NULL, -- ISO8601 timestamp of when indicator was calculated
        PRIMARY KEY (symbol, timestamp, interval, indicator_name, parameters_json, data_source)
    );

    CREATE INDEX IF NOT EXISTS idx_indicator_data_symbol_interval ON cached_indicator_data (symbol, interval);
    ```

## 5. State File Schemas (If applicable)

### GAStateCheckpoint

-   **Purpose:** Persists the state of the Genetic Algorithm to allow resumption of long runs. (PRD mentions HDF5/Parquet, but `pickle` is common for complex Python objects like GA populations).
-   **Format:** Python `pickle` (preferred for complex objects if security of checkpoint files is managed) or HDF5/Parquet for more structured data if feasible.
-   **Schema Definition (Conceptual for `pickle` - stores `GAIndividual` list and GA state):**
    *   The pickled object would typically be a dictionary or a custom class containing:
        *   `population`: `List[GAIndividual]` (or the internal representation used by the GA library)
        *   `generation_number`: `int`
        *   `random_state`: State of the random number generators (e.g., `random.getstate()`, `numpy.random.get_state()`)
        *   `hall_of_fame`: List of best individuals found so far.
        *   Other GA-specific state variables (e.g., internal state of selection operators).
-   **Path Template:** Defined in `config.yaml`, e.g., `ga_checkpoints/gen_{generation}.pkl`

### GAEvolutionLog

-   **Purpose:** Logs key metrics for each generation of the GA for analysis and tracking progress.
-   **Format:** JSON Lines (`.jsonl`) or CSV (`.csv`). JSON Lines preferred for richer structured data per entry.
-   **Schema Definition:** See `GAEvolutionLogEntry` Pydantic model above.
    *   **JSON Lines Example Entry:**
        ```json
        {"generation": 1, "timestamp": "2025-05-15T10:00:00Z", "best_fitness": 1.52, "average_fitness": 0.89, "population_size": 100, "best_individual_id": "strat_abc123"}
        ```
    *   **CSV Columns:** `generation,timestamp,best_fitness,average_fitness,population_size,best_individual_id`
-   **Path:** Defined in `config.yaml`, e.g., `ga_evolution_log.jsonl`

## 6. Report File Schemas (Implicit)

Output reports are generated in HTML, Markdown, and CSV formats. While not strictly defined by Pydantic models as input, their structure is derived from `ReportData`.

### HTML Report

-   **Structure:** Multi-section HTML document including summary statistics, detailed views of top N strategies (rules, backtest metrics, equity curves, trade lists), and GA evolution charts. Generated using a templating engine (e.g., Jinja2) with `ReportData`.

### Markdown Report

-   **Structure:** Similar content to the HTML report but in Markdown format for easier version control or integration into other documents. Tables for metrics and code blocks for strategy rules.

### CSV Report(s)

-   **`summary_metrics.csv`:** High-level backtest metrics for each of the top N strategies.
    *   Columns: `strategy_id`, `name`, `total_net_profit`, `sharpe_ratio`, `max_drawdown_percent`, `win_rate_percent`, `total_trades`, ... (subset of `BacktestMetrics`)
-   **`trades_strategy_{strategy_id}.csv`:** Detailed list of all trades for a specific strategy.
    *   Columns: `trade_id`, `symbol`, `entry_timestamp`, `entry_price`, `exit_timestamp`, `exit_price`, `shares`, `direction`, `profit_loss`, `profit_loss_percent` (from `Trade` model)

## 7. Change Log

| Change        | Date       | Version | Description                                       | Author         |
| ------------- | ---------- | ------- | ------------------------------------------------- | -------------- |
| Initial Draft | 2025-05-14 | 0.1     | High-level overview of data models.               | User/AI        |
| Revision 1    | 2025-05-15 | 0.2     | Expanded with Pydantic models, DB & file schemas. | Gemini 2.5 Pro |
